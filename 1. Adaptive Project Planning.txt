import React, { useState, useRef, useEffect, forwardRef } from "react";
import { Select, SelectProps, Option } from "@citi-icg-172888/icgds-react";
import _ from "lodash";

interface ISelectHocProps extends SelectProps {
  options: string[];
  onChange?: (selected: string[]) => void;
  width?: string;
  isDisabled?: boolean;
  error?: string;
  label?: string;
  multiSelect?: boolean;
}

const ITEM_HEIGHT = 40;
const VISIBLE_ITEM_COUNT = 5; // Controls how many items are visible at once

const SelectHoc = forwardRef<HTMLDivElement, ISelectHocProps>((props, ref) => {
  const { onChange, options, className, id, error, label, multiSelect } = props;
  const [isOpen, setIsOpen] = useState(false);
  const [highlightedIndex, setHighlightedIndex] = useState(-1);
  const [selectedOptions, setSelectedOptions] = useState<string[]>([]);

  const containerRef = useRef<HTMLDivElement | null>(null);
  const listRef = useRef<HTMLDivElement | null>(null);

  useEffect(() => {
    if (listRef.current) {
      const observer = new IntersectionObserver(
        (entries) => {
          const visibleIndexes = entries
            .filter((entry) => entry.isIntersecting)
            .map((entry) => Number(entry.target.getAttribute("data-index")));

          if (visibleIndexes.length > 0) {
            setHighlightedIndex(visibleIndexes[0]); // Auto-focus first visible item
          }
        },
        { root: listRef.current, rootMargin: "0px", threshold: 0.1 }
      );

      const listItems = listRef.current.querySelectorAll(".option-item");
      listItems.forEach((item) => observer.observe(item));

      return () => observer.disconnect();
    }
  }, [options]);

  const handleSelection = (option: string) => {
    let updatedSelection = multiSelect
      ? selectedOptions.includes(option)
        ? selectedOptions.filter((item) => item !== option)
        : [...selectedOptions, option]
      : [option];

    setSelectedOptions(updatedSelection);
    onChange && onChange(updatedSelection);

    if (!multiSelect) {
      setIsOpen(false);
    }
  };

  const handleKeyDown = (event: React.KeyboardEvent) => {
    switch (event.key) {
      case "ArrowDown":
        event.preventDefault();
        setHighlightedIndex((prev) => Math.min(prev + 1, options.length - 1));
        break;
      case "ArrowUp":
        event.preventDefault();
        setHighlightedIndex((prev) => Math.max(prev - 1, 0));
        break;
      case "Enter":
        event.preventDefault();
        if (highlightedIndex >= 0) {
          handleSelection(options[highlightedIndex]);
        }
        break;
      case "Escape":
        setIsOpen(false);
        break;
      default:
        break;
    }
  };

  return (
    <div
      className={className}
      tabIndex={0}
      ref={ref}
      onFocus={() => setIsOpen(true)}
      onBlur={() => setIsOpen(false)}
      onKeyDown={handleKeyDown}
      aria-expanded={isOpen}
      role="combobox"
      aria-haspopup="listbox"
      aria-owns={`${id}-listbox`}
      aria-controls={`${id}-listbox`}
      aria-label={label}
      aria-activedescendant={highlightedIndex >= 0 ? `${id}-option-${highlightedIndex}` : undefined}
      style={{
        position: "relative",
        width: props.width || "100%",
        maxWidth: "400px",
      }}
    >
      <Select
        {...props}
        id={id}
        style={{
          overflow: "hidden",
          textOverflow: "ellipsis",
          whiteSpace: "nowrap",
        }}
        aria-label={label}
        invalid={!!error}
        showSearch
        onChange={(option: any) => handleSelection(option)}
        getPopupContainer={() => document.querySelector("#root")}
      >
        {isOpen && (
          <div
            ref={containerRef}
            style={{
              height: ITEM_HEIGHT * VISIBLE_ITEM_COUNT,
              overflowY: "auto",
              position: "absolute",
              width: "100%",
              background: "#fff",
              boxShadow: "0px 4px 6px rgba(0,0,0,0.1)",
              borderRadius: "5px",
              marginTop: "5px",
              zIndex: 10,
            }}
          >
            <div ref={listRef}>
              {options.slice(0, VISIBLE_ITEM_COUNT).map((option, index) => (
                <Option
                  key={option}
                  className="option-item"
                  data-index={index}
                  label={option}
                  aria-label={option}
                  value={option}
                  id={`${id}-option-${index}`}
                  aria-selected={highlightedIndex === index}
                  style={{
                    width: "100%",
                    height: `${ITEM_HEIGHT}px`,
                    display: "flex",
                    alignItems: "center",
                    padding: "10px",
                    cursor: "pointer",
                    backgroundColor: highlightedIndex === index ? "#007bff" : "#fff",
                    color: highlightedIndex === index ? "#fff" : "#000",
                  }}
                  onMouseEnter={() => setHighlightedIndex(index)}
                  onClick={() => handleSelection(option)}
                >
                  {option}
                </Option>
              ))}
            </div>
          </div>
        )}
      </Select>
    </div>
  );
});

SelectHoc.defaultProps = {
  highlightOption: true,
  mode: "default",
  tagColor: "selected",
  multiSelect: false,
};

export default SelectHoc;
