B — Keep three useState but set a single "ready" marker (works but clunkier)
import React, { useState, useEffect } from 'react';

function MyComponent({ onSubmitSearch }) {
  const [searchValue, setSearchValue] = useState(null);
  const [currentCaseId, setCurrentCaseId] = useState(null);
  const [selectedSearchType, setSelectedSearchType] = useState(null);
  // marker to indicate "these three were updated as part of the same response"
  const [caseReadyKey, setCaseReadyKey] = useState(null);

  useEffect(() => {
    if (caseReadyKey && searchValue && selectedSearchType === 'caseId' && currentCaseId) {
      console.log('All set -> trigger search', { searchValue, selectedSearchType, currentCaseId });
      onSubmitSearch(false);
      // optionally reset marker:
      setCaseReadyKey(null);
    }
  }, [caseReadyKey, searchValue, selectedSearchType, currentCaseId, onSubmitSearch]);

  // in your API .then(...)
  const handleResponse = (response) => {
    const id = response.data?.case?.caseId;
    // set the three states (they may update in separate microtasks),
    // then set marker that signals the effect to check them
    setSearchValue(id);
    setCurrentCaseId(id);
    setSelectedSearchType('caseId');
    setCaseReadyKey(Date.now()); // unique marker / timestamp
  };

  return <div>{/* UI */}</div>;
}


Why this works: caseReadyKey tells your effect to check that all three values reached the expected values. It's a workaround — not as elegant as useReducer but useful when you must keep useState calls.
